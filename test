param (
    [string]$Env
)

# Check if Env parameter is provided
if (-not $Env) {
    Write-Output "No environment specified. Use the -Env flag to specify an environment (DEV, PROD, QA)."
    exit
}

# Define path to the config file (using $PSScriptRoot for portability)
$configFilePath = "$PSScriptRoot\config\config.ini"

# Function to parse the INI file for a specific environment
function Parse-IniFileForEnv {
    param (
        [string]$filePath,
        [string]$environment
    )

    $iniContent = Get-Content -Path $filePath -ErrorAction Stop
    $config = @{}
    $sectionFound = $false

    foreach ($line in $iniContent) {
        # Trim whitespace from start and end of line
        $line = $line.Trim()

        # Ignore comments and empty lines
        if ($line -match '^\s*;') { continue }
        if ($line -eq '') { continue }

        # Look for the specified section header, e.g., [DEV]
        if ($line -match "^\[$environment\]") {
            $sectionFound = $true
            continue
        }

        # Exit the loop once we reach the next section
        if ($line -match '^\[' -and $sectionFound) {
            break
        }

        # If we are in the right section, look for specific variables
        if ($sectionFound -and $line -match '^\s*(.+?)\s*=\s*(.+?)\s*$') {
            $key, $value = $matches[1], $matches[2]

            # Only capture specific required keys
            if ($key -in @("identityDomain", "PCloudDomain", "PVWAMasterPolicy")) {
                $config[$key] = $value
            }
        }
    }

    # Check if the section was found and required keys are present
    if (-not $sectionFound) {
        Write-Output "Environment '$environment' not found in config file."
        exit 1
    }

    # Verify all required keys are present
    $requiredKeys = @("identityDomain", "PCloudDomain", "PVWAMasterPolicy")
    foreach ($key in $requiredKeys) {
        if (-not $config.ContainsKey($key)) {
            Write-Output "Missing required configuration key '$key' in environment '$environment'."
            exit 1
        }
    }

    return $config
}

# Parse the INI file for the specified environment
try {
    $envConfig = Parse-IniFileForEnv -filePath $configFilePath -environment $Env
    Write-Output "Configuration for environment '$Env' loaded successfully."
} catch {
    Write-Output "Failed to load configuration: $_"
    exit 1
}

# Access and output the specific configuration values
Write-Output "identityDomain: $($envConfig['identityDomain'])"
Write-Output "PCloudDomain: $($envConfig['PCloudDomain'])"
Write-Output "PVWAMasterPolicy: $($envConfig['PVWAMasterPolicy'])"


######################################



# Define the path to the config file
$configFilePath = ".\config.ini"

# Function to parse the INI file
function Parse-IniFile {
    param (
        [string]$filePath
    )

    $iniContent = Get-Content -Path $filePath -ErrorAction Stop
    $config = @{}
    $section = $null

    foreach ($line in $iniContent) {
        # Remove any whitespace from the start and end of the line
        $line = $line.Trim()

        # Ignore empty lines or comments
        if ($line -match '^\s*;') { continue }
        if ($line -eq '') { continue }

        # Check for section header, e.g., [DEV]
        if ($line -match '^\[(.+?)\]') {
            $section = $matches[1]
            $config[$section] = @{}
        }
        # Check for key-value pairs within a section, e.g., pamfqdn=https://someaddress.com
        elseif ($line -match '^\s*(.+?)\s*=\s*(.+?)\s*$' -and $section) {
            $key, $value = $matches[1], $matches[2]
            $config[$section][$key] = $value
        }
    }

    return $config
}

# Parse the INI file
try {
    $config = Parse-IniFile -filePath $configFilePath
    Write-Output "Configuration loaded successfully."
} catch {
    Write-Output "Failed to load configuration: $_"
    exit 1
}

# Access configuration values
$environment = "DEV"  # Example: specify the environment
Write-Output "PAM FQDN for $environment: $($config[$environment]['pamfqdn'])"
Write-Output "Username for $environment: $($config[$environment]['username'])"
Write-Output "Password for $environment: $($config[$environment]['password'])"


#############################################

# Define the OU from which to retrieve the groups
$ou = "OU=Groups,DC=YourDomain,DC=com"

# Initialize an array to hold all group data
$groupData = @()

# Get all groups in the specified OU
$groups = Get-ADGroup -Filter * -SearchBase $ou

# Iterate over each group and get their members
foreach ($group in $groups) {
    # Create a custom object to hold group and member information
    $groupObject = @{
        GroupName = $group.Name
        Members   = @()
    }

    # Get group membership
    $members = Get-ADGroupMember -Identity $group

    # Check if the group has any members
    if ($members.Count -gt 0) {
        # Add each member's name to the Members array
        foreach ($member in $members) {
            $groupObject.Members += @{
                MemberName = $member.Name
                ObjectType = $member.objectClass
            }
        }
    }

    # Add the group object to the groupData array
    $groupData += $groupObject
}

# Convert the group data array to JSON
$jsonOutput = $groupData | ConvertTo-Json -Depth 3

# Save the JSON output to a file in the current directory
$path = "$PSScriptRoot\GroupMembership.json"
$jsonOutput | Out-File -FilePath $path

# Inform the user where the file is saved
Write-Host "Group membership information saved to $path"
